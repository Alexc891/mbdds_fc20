```{r include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(knitr)
library(pander)
library(kableExtra)
library(datos)
suppressPackageStartupMessages(library(tidyverse))
panderOptions('table.split.table', Inf)
panderOptions('decimal.mark', ",")
panderOptions('big.mark', ".")
panderOptions('missing', "")
options(knitr.kable.NA = '')

#En libreoffice para eliminar las lineas con resultados: 
#  Reemplazar > expresiones regulares > ##.*
```

<br>

## 1.6. Control de flujo

<br>

Existen distintos mecanismos para controlar el flujo de un programa. 

<br>

### 1.6.1. Funciones

<br>

Las funciones ayudan a automatizar piezas de nuestro código. 

Un caso particular de funciones son las **funciones vectorizadas**. Éstas se aplican tantas veces como elementos tengamos en la entrada de la función. 

Veamos unos ejemplos simples.

<br>

```{r}
a <- seq(2,8,2)
a
a + a
sqrt(a)
```

<br>

Estas funciones se aplican a cada uno de los elementos del objeto `a`.

Otro ejemplo, sería una función para reemplazar los valores faltantes con el valor cero.

<br>

```{r}
a <- c(3, NA, -8, NA)
remplazar_na_cero <- function(x) {
  x[is.na(x)] <- 0
  return(x)
}
remplazar_na_cero(a)
```

<br>

En los siguientes puntos se presenta como vectorizar funciones sobre objetos R (vectores, listas, data frames...).  

<br>

### 1.6.2. Condicionales

<br>

Una forma de modificar el flujo de un programa, es mediante el uso de expresiones `if-then-else`.

<br>

```{r}
a <- 1
b <- 1

if (a > b){
  print("a mayor que b")
} else if (a < b) {
  print("a menor que b")
} else {
  print("a igual a b")
}
```

<br>

La expresión `if()` evalúa un único valor lógico. Es habitual el uso de `any()` y `all()` para tratar condiciones sobre vectores.

<br>

```{r}
a <- c(4, NA, 5) 

if (all(is.na(a))) {
  print("todos son NA")
} else if(any(is.na(a))) {
  print("hay algun NA")
} else {
  print("no hay NA")
}
```

<br>

La función `ifelse()`, en cambio, sí que vectoriza.

<br>

```{r}
a <- c(2:-2)
a
sqrt(a)
sqrt(ifelse(a>=0, a, NA))
```

<br>

`sqrt()` al aplicarse sobre valores negativos, devuelve un nuevo valor `NaN` (acrónimo de *Not a Number*). La expresión `ifelse()` evita el NaN devolviendo un `NA`.

En R, habitualmente se utiliza la siguiente alternativa basada en filtros.

<br>

```{r}
raiz <- rep(NA, length(a))
raiz[a>=0] <- sqrt(a[a>=0])
raiz
```

<br>

### 1.6.3. Bucles

<br>

Si bien existen bucles de tipo `while()` y `repeat`, el más habitual es `for()`. 
Para calcular el cuadrado de un vector de números con `for()`.

<br>

```{r}
a <- seq(2,8,2)
a
cuadrados <- NULL

for (x in a){
  cuadrados <- c(cuadrados, x^2) 
}
cuadrados
```

<br>

`x` recorre los elementos del objeto `a` y acumula el resultado en `cuadrados`. 
Esto, es poco eficiente, ya que obliga a ir ampliando la memoria en cada iteración. La forma correcta es, primero reservar el espacio y posteriormente rellenar el objeto:

<br>

```{r}
cuadrados <- rep(NA,length(a))

for (i in 1:length(a)){
  cuadrados[i] <- a[i]^2
}
cuadrados
```

<br>

Ahora se recorren los indices, no los valores de `a`.

No obstante, en R, es más simple utilizar funciones vectorizadas.

<br>

```{r}
cuadrados <- a^2
cuadrados
```

<br>

En el apartado de [RESUMENES DE AGREGADOS](#resumenes-de-agregados), se muestran las funciones  `apply()` que permiten vectorizar operaciones sobre colecciones de objetos.


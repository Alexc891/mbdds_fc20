```{r include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.path="www/")
library(knitr)
library(pander)
library(kableExtra)
library(datos)
library(ggrepel)
suppressPackageStartupMessages(library(tidyverse))
panderOptions('table.split.table', Inf)
panderOptions('decimal.mark', ",")
panderOptions('big.mark', ".")
panderOptions('missing', "")
options(knitr.kable.NA = '')

#En libreoffice para eliminar las lineas con resultados: 
#  Reemplazar > expresiones regulares > ##.*
paises07 <- as.data.frame(paises %>% filter(anio==2007))
```

<br>

## 1.7. Gestión de datos

<br>

A continuación, se presentan las funciones para la lectura/escritura de datos, cruce y construcción de tablas resumen. 

<br>

### 1.7.1 Importar y exportar datos

<br>

RStudio aporta facilidades para la importación de datos a través del menú: `File -> Import Data set -> From Text...`

<br>

#### LECTURA TEXTO CON SEPARADOR

<br>

Para leer el siguiente fichero de texto:

<br>

```{r, eval=FALSE}
cat(paste0(readLines("www/mtcars.csv", n = 6), collapse="\n"))
```

<br>

```{r echo=FALSE, results='hide', warning=FALSE}
a<-data.frame(readLines("www/mtcars.csv", n = 6))
kable(a, "html", booktabs=TRUE,align="r",row.names = FALSE,col.names = NULL) %>%
  kable_styling(bootstrap_options="basic",font_size = 11,full_width = F) %>%
  column_spec(1,monospace=TRUE) %>%
  save_kable("www/readmtcars0.png")
```

![](www/readmtcars0.png){width=400px}

\<imagen1\>(www/readmtcars0.png){width=400px}

<br>

Dado que se trata de un fichero con un carácter separador, la función genérica para este tipo de ficheros es `read.table()`.

<br>

```{r}
mtcars <- read.table("www/mtcars.csv", dec=".",sep=",", header=TRUE)
```

<br>

Los parámetros especificados son:

- `dec`: El separador decimal. En Europa se acostumbra a utilizar la coma ",".
- `sep`: El separador de columnas. Es habitual usar también ";" y "\\t" cuando es un tabulador.
- `header`: Indica si la primera fila contiene el nombre de las columnas o no.

<br>

También es común el uso de `fileEncoding="Latin1"` cuando el fichero se ha creado con Windows y utiliza caracteres especiales de texto (tildes, ...).

Dada la estructura del fichero, con `read.csv()` la carga es más simple.

<br>

```{r}
mtcars <- read.csv("www/mtcars.csv")
```

<br>

Cuando el csv es europeo, "," decimal y ";" como separador, se utiliza `read.csv2()`.

Es una buena práctica verificar su carga con `dim()`, `head()` y `summary()`.

<br>

```{r}
dim(mtcars)
```

<br>

```{r, eval=FALSE}
head(mtcars)
```

<br>

```{r echo=FALSE, results='hide', warning=FALSE}
options(knitr.kable.NA = NA)
kable(head(mtcars), "html", booktabs=TRUE,align="r", row.names = TRUE,) %>%
  kable_styling(bootstrap_options=c("striped", "hover", "condensed", "responsive")
                ,font_size = 11,full_width = F,) %>%
  column_spec(1:ncol(head(mtcars)),monospace=TRUE) %>%
  save_kable("www/mtcars.png")
options(knitr.kable.NA = '')
```

![](www/mtcars.png){width=350px}

\<imagen1\>(www/mtcars.png){width=350px}

<br>

```{r, eval=FALSE}
summary(mtcars)
```

<br>

```{r echo=FALSE, results='hide', warning=FALSE}
options(knitr.kable.NA = NA)
kable(summary(mtcars), "html", booktabs=TRUE,align="r", row.names = TRUE,) %>%
  kable_styling(bootstrap_options=c("striped", "hover", "condensed", "responsive")
                ,font_size = 9,full_width = F,) %>%
  column_spec(1:ncol(summary(mtcars)),monospace=TRUE) %>%
  save_kable("www/mtcars2.png")
options(knitr.kable.NA = '')
```

![](www/mtcars2.png){width=800px}

\<imagen1\>(www/mtcars2.png){width=800px}

<br>

#### ESCRITURA TEXTO CON SEPARADOR

<br>

Para la escritura, puedes utilizar sus equivalentes: `write.table()`, `write.csv()`, `write.csv2()`. Cabe destacar algunas pequeñas variaciones.  

<br>

```{r}
write.csv2(mtcars, file="www/mtcars2.csv", row.names=FALSE, na="")
```

<br>

- `row.names`: Si no se especifica, por defecto, se inserta el número de fila.
- `na`: Si no se especifica, introduce el texto `NA`.

<br>

Observa como el nuevo csv ahora tiene el formato de csv europeo.

<br>

```{r, eval=FALSE}
cat(paste0(readLines("www/mtcars2.csv", n = 6), collapse="\n"))
```

<br>

```{r echo=FALSE, results='hide', warning=FALSE}
a<-data.frame(readLines("www/mtcars2.csv", n = 6))
kable(a, "html", booktabs=TRUE,align="r",row.names = FALSE,col.names = NULL) %>%
  kable_styling(bootstrap_options="basic",font_size = 11,full_width = F) %>%
  column_spec(1,monospace=TRUE) %>%
  save_kable("www/readmtcars.png")
```

![](www/readmtcars.png){width=400px}

\<imagen1\>(www/readmtcars.png){width=400px}

<br>

#### TEXTO CON ANCHO FIJO

<br>

Veamos un ejemplo de fichero de ancho fijo:

<br>

```{r, eval=FALSE}
cat(paste0(readLines("www/fwf-sample.txt", n = 6), collapse="\n"))
```

<br>

```{r echo=FALSE, results='hide', warning=FALSE}
a<-data.frame(readLines("www/fwf-sample.txt", n = 6))
kable(a, "html", booktabs=TRUE,align="r",row.names = FALSE,col.names = NULL) %>%
  kable_styling(bootstrap_options="basic",font_size = 11,full_width = F) %>%
  column_spec(1,monospace=TRUE) %>%
  save_kable("www/fwf-sample0.png")
```

![](www/fwf-sample0.png){width=175px}

\<imagen1\>(www/fwf-sample0.png){width=175px}

<br>

Para leer texto de ancho fijo, se utiliza `read.fwf()`.

<br>

```{r}
fwf_sample <- read.fwf("www/fwf-sample.txt", widths=c(20,10,12)
                     , col.names=c("name", "state", "ssn"))
```

<br>

- `widths`: Son los anchos de cada columna.
- `col.names`: Nombres de las columnas.

<br>

```{r, eval=FALSE}
fwf_sample
```

<br>

```{r echo=FALSE, results='hide', warning=FALSE}
kable(fwf_sample, "html", booktabs=TRUE,align="r", row.names = TRUE,) %>%
  kable_styling(bootstrap_options=c("striped", "hover", "condensed", "responsive")
                ,font_size = 11,full_width = F,) %>%
  column_spec(1:ncol(fwf_sample),monospace=TRUE) %>%
  save_kable("www/fwf-sample.png")
options(knitr.kable.NA = '')
```

![](www/fwf-sample.png){width=175px}

\<imagen1\>(www/fwf-sample.png){width=175px}

<br>

### 1.7.2 Cruce entre tablas

<br>

Para cruzar 2 o más tablas es necesario que éstas compartan un conjunto de índices. 

<br>

#### CRUCES POR ORDENACIÓN

<br>

Una forma indexar consiste simplemente en compartir una misma ordenación de filas o columnas.

<br>

##### ORDENACION DE TABLAS

<br>

Para ordenar un vector se utiliza la función `sort()`.

<br>

```{r}
a <- c(5,2,9,4)
sort(a)
```

<br>

Lo mismo se puede hacer en dos pasos. Primero, con order() se obtienen los índices de ordenación.

<br>

```{r}
indices_ordenacion <- order(a)
indices_ordenacion
```

<br>

Segundo se seleccionan los elementos del vector `a` en ese orden.

<br>

```{r}
a[indices_ordenacion]
```

<br>

Observa que el resultado es idéntico a utilizar directamente `sort()`.

Mismo principio ahora, para ordenar la tabla `paises07` por continente (decreciente) y esperanza de vida (creciente).

<br>

```{r}
paises07Ord <- paises07[order(paises07$continente,paises07$esperanza_de_vida
                              ,decreasing = c(T,F)),]
```

<br>

```{r, eval=FALSE}
head(paises07Ord)
```

<br>

```{r echo=FALSE, results='hide', warning=FALSE}
kable(head(paises07Ord), "html", booktabs=TRUE,align="r", row.names = TRUE,) %>%
  kable_styling(bootstrap_options=c("striped", "hover", "condensed", "responsive")
                ,font_size = 11,full_width = F,) %>%
  column_spec(1:ncol(head(paises07Ord)),monospace=TRUE) %>%
  save_kable("www/paisesOrd.png")
options(knitr.kable.NA = '')
```

![](www/paisesOrd.png){width=400px}

\<imagen1\>(www/paisesOrd.png){width=400px}

<br>

##### UNIÓN POR COLUMNAS

<br>

Para unir las columnas de 2 tablas que comparten ordenación de sus filas se utiliza `cbind()`.

<br>

```{r}
a1 <- paises07[,1:2]
a2 <- paises07[,4:5]
a <- cbind(a1, a2)
```

<br>

```{r, eval=FALSE}
head(a)
```

<br>

```{r echo=FALSE, results='hide', warning=FALSE}
kable(head(a), "html", booktabs=TRUE,align="r", row.names = TRUE,) %>%
  kable_styling(bootstrap_options=c("striped", "hover", "condensed", "responsive")
                ,font_size = 11,full_width = F,) %>%
  column_spec(1:ncol(head(a)),monospace=TRUE) %>%
  save_kable("www/paiscbind.png")
options(knitr.kable.NA = '')
```

![](www/paiscbind.png){width=275px}

\<imagen1\>(www/paiscbind.png){width=275px}

<br>

##### UNIÓN POR FILAS

<br>

Unir las filas de dos tablas con la misma ordenación de sus columnas `rbind()`.

<br>

```{r}
a1 <- paises07[1:2,]
a2 <- paises07[4:5,]
a <- rbind(a1, a2)
```

```{r, eval=FALSE}
head(a)
```

<br>

```{r echo=FALSE, results='hide', warning=FALSE}
kable(head(a), "html", booktabs=TRUE,align="r", row.names = TRUE,) %>%
  kable_styling(bootstrap_options=c("striped", "hover", "condensed", "responsive")
                ,font_size = 11,full_width = F,) %>%
  column_spec(1:ncol(head(a)),monospace=TRUE) %>%
  save_kable("www/paiscbind1.png")
options(knitr.kable.NA = '')
```

![](www/paiscbind1.png){width=275px}

\<imagen1\>(www/paiscbind1.png){width=275px}

<br>

#### CRUCE POR CAMPOS CLAVE

<br>

Un campo clave consiste en una columna que identifica cada registro de forma única.

Por ejemplo, `pais` y `continente` son campos clave ya que identifican de forma única a sus respectivas entidades en la tabla de `paises`.

Antes de realizar cualquier cruce por campos clave, es importante saber si éste tiene o no duplicados. 

<br>

##### VECTOR DE CLAVES

<br>

Para obtener las claves únicas de un vector utiliza `unique()`.

<br>

```{r}
sort(unique(as.character(paises07$continente)))
```

<br>

Para saber qué filas de un data frame están duplicadas, utiliza `duplicated()`.

<br>

```{r}
paisesDup <- paises07[c(1,1,2,3,3,4,5,5,6),]
any(duplicated(paisesDup))    # ¿Tiene duplicados?
as.character(paisesDup$pais[duplicated(paisesDup)]) # que países son
```

<br>

##### FUSIÓN CON CLAVES

<br>

Para cruzar 2 tablas con claves, utiliza `merge()`.

<br>

###### INNER JOIN

<br>

Analiza el siguiente ejemplo:

<br>

```{r}
a1 <- data.frame(ID = c(1,2,3), X1 = c(1,1,2), X2 = c("b","a","a"))
a2 <- data.frame(ID = c(2,3,3,4), X1 = c(1,1,2,2), X3 = c(FALSE, TRUE, FALSE, FALSE))
a_inner <- merge(a1, a2)
```

```{r, eval=FALSE}
a_inner
```

<br>

```{r echo=FALSE, results='hide', warning=FALSE}
a<- a_inner
options(knitr.kable.NA = 'NA')
kable(head(a), "html", booktabs=TRUE,align="r", row.names = TRUE,) %>%
  kable_styling(bootstrap_options=c("striped", "hover", "condensed", "responsive")
                ,font_size = 11,full_width = F,) %>%
  column_spec(1:ncol(head(a)),monospace=TRUE) %>%
  save_kable("www/a_inner.png")
options(knitr.kable.NA = '')
```

![](www/a_inner.png){width=115px}

\<imagen1\>(www/a_inner.png){width=115px}

<br>

R, ha seleccionado `ID` y `X1` como campos clave porque son las columnas con nombres coincidentes en ambas tablas. Veremos cómo modificar esto.

Otra decisión que R ha tomado, es que **sólo** ha recuperado los **registros** con valores de `ID` y `X1` **compartidos** en ambas tablas. Este comportamiento en el lenguaje SQL, es conocido como *INNER JOIN*.

<br>

###### FULL JOIN

<br>

Para conservar **todos los registros de las tablas originales**, tanto de la tabla izquierda como derecha, coincida o no, se utiliza el parámetro `all=TRUE`.

<br>

```{r}
a_full <- merge(a1, a2, all = TRUE)
```

```{r, eval=FALSE}
a_full
```

<br>

```{r echo=FALSE, results='hide', warning=FALSE}
a<- a_full
options(knitr.kable.NA = 'NA')
kable(head(a), "html", booktabs=TRUE,align="r", row.names = TRUE,) %>%
  kable_styling(bootstrap_options=c("striped", "hover", "condensed", "responsive")
                ,font_size = 11,full_width = F,) %>%
  column_spec(1:ncol(head(a)),monospace=TRUE) %>%
  save_kable("www/a_full.png")
options(knitr.kable.NA = '')
```

![](www/a_full.png){width=115px}

\<imagen1\>(www/a_full.png){width=115px}

<br>

Observa ahora, no ha descartado ningún registro de las tablas origen. Además, ha rellenado con `NA` los campos que no cruzan. Este comportamiento en SQL es conocido como *FULL JOIN* .

<br>

<piensa un minuto>Intenta realizar tu mismo **LEFT JOIN**  (resp. **RIGHT JOIN**) utilizando `all.x = TRUE` (resp. `all.x = TRUE`).</ piensa un minuto>

<br>

###### DEFINCIÓN DE LAS CLAVES

<br>

Puedes pasar los nombre de las columnas clave del cruce como parámetros:

- Si son compartidos utiliza `by`. 
- Cuando no, utiliza `by.x` y `by.y`

<br>

Observa el siguiente ejemplo.

<br>

```{r}
a_comparte <- merge(a1, a2, all.x=TRUE, by = c("ID")) 
# equivalentemente
a_comparte <- merge(a1, a2, all.x=TRUE, by.x = c("ID"), by.y = c("ID"))
```

```{r, eval=FALSE}
a_comparte
```

<br>

```{r echo=FALSE, results='hide', warning=FALSE}
a<- a_comparte
options(knitr.kable.NA = 'NA')
kable(head(a), "html", booktabs=TRUE,align="r", row.names = TRUE,) %>%
  kable_styling(bootstrap_options=c("striped", "hover", "condensed", "responsive")
                ,font_size = 11,full_width = F,) %>%
  column_spec(1:ncol(head(a)),monospace=TRUE) %>%
  save_kable("www/a_comparte.png")
options(knitr.kable.NA = '')
```

![](www/a_comparte.png){width=140px}

\<imagen1\>(www/a_comparte.png){width=140px}

<br>

R ha añadido el sufijo `.x` y `.y` a `X1`, porque es una columna compartida que ahora no es clave para el cruce. Observa también que ID=3 aparece 2 veces ya que está duplicado en la tabla `a2`.

<br>

### 1.7.3 Resúmenes de agregados

<br>

R tiene muchas opciones para construir agregados.

<br>

#### SUMMARY

<br>

Para tener una primera impresión sobre los datos utiliza `summary()`.

<br>

```{r}
paises07Summ <- paises07
paises07Summ$pais <- as.character(paises07Summ$pais)
paises07Summ$fecha <- as.Date(paste(paises07Summ$anio,"12","31",sep="-"),"%Y-%m-%d")
paises07Summ$es_grande <- paises07Summ$poblacion > 30*10^6
paises07Summ$pib_per_capita[c(34,70,108)] <- NA
```

```{r, eval=FALSE}
summary(paises07Summ[,c("pais","continente","pib_per_capita","es_grande","fecha"),])
```

<br>

```{r echo=FALSE, results='hide', warning=FALSE}
a<- summary(paises07Summ[,c("pais","continente","pib_per_capita","es_grande","fecha"),])
#options(knitr.kable.NA = 'NA')
kable(a, "html", booktabs=TRUE,align="r", row.names = TRUE,) %>%
  kable_styling(bootstrap_options=c("striped", "hover", "condensed", "responsive")
                ,font_size = 11,full_width = F,) %>%
  column_spec(1:ncol(a),monospace=TRUE) %>%
  save_kable("www/paisSumm1.png")
options(knitr.kable.NA = '')
```

![](www/paisSumm1.png){width=400px}

\<imagen1\>(www/paisSumm1.png){width=400px}

<br>

`summary` en `factor` y `logic` devuelve una tabla de frecuencias o conteos, en cambio en `character` no. En `numeric`y `Date` devuelve 6 estadísticos básicos de resumen más el conteo de `NA`s.

<br>

#### ESTADÍSTICOS BASICOS

<br>

Los 6 estadísticos básicos del summary son:

<br>

```{r}
min(paises07Summ$pib_per_capita, na.rm=TRUE)
quantile(paises07Summ$pib_per_capita, 0.25, na.rm=TRUE)
median(paises07Summ$pib_per_capita, na.rm=TRUE)
mean(paises07Summ$pib_per_capita, na.rm=TRUE)
quantile(paises07Summ$pib_per_capita, 0.75, na.rm=TRUE)
max(paises07Summ$pib_per_capita, na.rm=TRUE)
```

<br>

El parámetro `na.rm=TRUE` elimina los `NA` antes de aplicar la función, en caso contrario devuelve `NA`. 

<br>

La función `quantile()`, por sí sola, puede calcular todos los valores, excepto la media.

<br>

```{r, eval=FALSE}
quantile(paises07Summ$pib_per_capita, seq(0,1,1/4), na.rm=TRUE)
```

<br>

```{r echo=FALSE, results='hide', warning=FALSE}
a<- t(quantile(paises07Summ$pib_per_capita, seq(0,1,1/4), na.rm=TRUE))
#options(knitr.kable.NA = 'NA')
kable(a, "html", booktabs=TRUE,align="r") %>%
  kable_styling(bootstrap_options=c("striped", "hover", "condensed", "responsive")
                ,font_size = 11,full_width = F,) %>%
#  column_spec(1:5,monospace=TRUE) %>%
  save_kable("www/paisSumm1_1.png")
options(knitr.kable.NA = '')
```

![](www/paisSumm1_1.png){width=250px}

\<imagen1\>(www/paisSumm1_1.png){width=250px}

<br>

#### TABLAS DE FRECUENCIAS O CONTEOS

<br>

Para obtener una tabla de frecuencias o conteos, utiliza `table()`. Para una columna.

<br>

```{r, eval=FALSE}
table(paises07Summ$continente)  # una columna
```

<br>

```{r echo=FALSE, results='hide', warning=FALSE}
a<- t(table(paises07Summ$continente))  # una variable
#options(knitr.kable.NA = 'NA')
kable(a, "html", booktabs=TRUE,align="r") %>%
  kable_styling(bootstrap_options=c("striped", "hover", "condensed", "responsive")
                ,font_size = 11,full_width = F,) %>%
  column_spec(1:5,monospace=TRUE) %>%
  save_kable("www/paisSumm2.png")
options(knitr.kable.NA = '')
```

![](www/paisSumm2.png){width=200px}

\<imagen1\>(www/paisSumm2.png){width=200px}

<br>

Tablas cruzadas de dos o más columnas.

<br>

```{r, eval=FALSE}
table(paises07Summ$continente,paises07Summ$es_grande)
```

<br>

```{r echo=FALSE, results='hide', warning=FALSE}
a<- table(paises07Summ$continente,paises07Summ$es_grande)
#options(knitr.kable.NA = 'NA')
kable(a, "html", booktabs=TRUE,align="r", row.names = TRUE) %>%
  kable_styling(bootstrap_options=c("striped", "hover", "condensed", "responsive")
                ,font_size = 11,full_width = F,) %>%
  column_spec(1:3,monospace=TRUE) %>%
  save_kable("www/paisSumm3.png")
options(knitr.kable.NA = '')
```

![](www/paisSumm3.png){width=125px}

\<imagen1\>(www/paisSumm3.png){width=125px}

<br>

> \<sabías que\>Asia es el continente con mayor número de países grandes (de más de 30M de hab.)\</sabías que\>. 

<br>

En muchas ocasiones, es útil tramar las columna numéricas en intervalos. En R utiliza `cut()`.

<br>

Vamos a crear la columna nivel de riqueza a partir del pib_per_capita cortando la columna por 1700$ y 18000$.

<br>

```{r}
paises07Summ$nivel_de_riqueza <- cut(paises07Summ$pib_per_capita, 
                                         breaks=c(-Inf,1700,18000,Inf))
```

```{r, eval=FALSE}
head(paises07Summ[,c("pais","pib_per_capita","nivel_de_riqueza")])
```

<br>

```{r echo=FALSE, results='hide', warning=FALSE}
a<- head(paises07Summ[,c("pais","pib_per_capita","nivel_de_riqueza")])
#options(knitr.kable.NA = 'NA')
kable(a, "html", booktabs=TRUE,align="r", row.names = TRUE) %>%
  kable_styling(bootstrap_options=c("striped", "hover", "condensed", "responsive")
                ,font_size = 11,full_width = F,) %>%
  column_spec(1:ncol(a),monospace=TRUE) %>%
  save_kable("www/paisSumm4.png")
options(knitr.kable.NA = '')
```

![](www/paisSumm4.png){width=250px}

\<imagen1\>(www/paisSumm4.png){width=250px}

<br>

> \<recuerda\>Para definir los `breaks`, R permite utilizar `-Inf` e `Inf` (infinito) como si fueran números.\</recuerda\>

<br>

`cut()` crea un `factor` ordenado a partir de la columna `numeric` con los siguientes levels:

<br>

```{r}
levels(paises07Summ$nivel_de_riqueza)
```

<br>

Para modificar las etiquetas utiliza la misma función `levels()`. 

<br>

```{r}
levels(paises07Summ$nivel_de_riqueza) <- c("Pobres","Medios","Ricos")
```

<br>

Mostramos a continuación la distribución de países ricos y pobres por continente en 2007.

<br>

```{r, eval=FALSE}
table(paises07Summ$continente, paises07Summ$nivel_de_riqueza, useNA = "ifany")
```

<br>

```{r echo=FALSE, results='hide', warning=FALSE}
a<- table(paises07Summ$continente, paises07Summ$nivel_de_riqueza, useNA = "ifany")
#options(knitr.kable.NA = 'NA')
kable(a, "html", booktabs=TRUE,align="r", row.names = TRUE) %>%
  kable_styling(bootstrap_options=c("striped", "hover", "condensed", "responsive")
                ,font_size = 11,full_width = F,) %>%
  column_spec(1:ncol(a),monospace=TRUE) %>%
  save_kable("www/paisSumm5.png")
options(knitr.kable.NA = '')
```

![](www/paisSumm5.png){width=175px}

\<imagen1\>(www/paisSumm5.png){width=175px}

<br>

Gráficamente.

<br>

```{r plot7, warning=FALSE, message=FALSE, fig.cap="Riqueza por continente. (plot7-1.png)"}
ggplot(paises07Summ) +
  geom_bar(aes(x=continente, fill=nivel_de_riqueza), position = "fill") +
  labs(y="%")
```

<br>

> \<recuerda\>Para definir el nivel de riqueza de los países en 2007 se ha realizado la siguiente transformación:\</recuerda\>

<br>

```{r}
paises07$nivel_de_riqueza <- cut(paises07$pib_per_capita, breaks=c(-Inf,1700,18000,Inf))
levels(paises07$nivel_de_riqueza) <- c("Pobres","Medios","Ricos")
```

<br>

#### AGREGADOS POR SUBGRUPOS

<br>

Además de frecuencias o conteos, es necesario saber calcular otros estadísticos básicos para subgrupo de un data frame. Por ejemplo, la media de esperanza de vida y del pib per cápita, así como, el total de población por continente y nivel de riqueza.

<br>

```{r}
agg1 <- aggregate(paises07[,c("esperanza_de_vida","pib_per_capita")],
                  list(continente = paises07$continente
                       , nivel_de_riqueza=paises07$nivel_de_riqueza),mean)
agg2 <- aggregate(paises07[,c("poblacion"),drop=FALSE],
                  list(continente = paises07$continente
                       , nivel_de_riqueza=paises07$nivel_de_riqueza),sum)
```

<br>

> \<recuerda\>aggregate() permite calcular un mismo estadístico sobre varias columnas segmentando por más de un eje.\</recuerda\>

<br>

Se juntan ahora los dos agregados con `merge()` y se genera la columna combinada `continente_riqueza`.

<br>

```{r}
agg3 <- merge(agg1,agg2)
agg3$continente_riqueza <- paste(agg3$continente,agg3$nivel_de_riqueza,sep="-")
```

```{r, eval=FALSE}
agg3
```

<br>

```{r echo=FALSE, results='hide', warning=FALSE}
a<- agg3
options(knitr.kable.NA = 'NA')
kable(a, "html", booktabs=TRUE,align="r", row.names = TRUE) %>%
  kable_styling(bootstrap_options=c("striped", "hover", "condensed", "responsive")
                ,font_size = 11,full_width = F,) %>%
  column_spec(1:ncol(a),monospace=TRUE) %>%
  save_kable("www/paisSumm6.png")
options(knitr.kable.NA = '')
```

![](www/paisSumm6.png){width=400px}

\<imagen1\>(www/paisSumm6.png){width=400px}

<br>

El mismo gráfico visto para países, ahora, agregado a nivel de continente y riqueza.

<br>

```{r plot8, warning=FALSE, message=FALSE, fig.cap='Continentes (Fuente: Elaboración propia, datos de Gapminder). (plot8-1.png)'}
ggplot(agg3, aes(x=pib_per_capita
                          , y=esperanza_de_vida
                          , label=continente_riqueza
                          , color =continente
                          , size=poblacion)) +
  geom_point() +
  geom_label_repel(size=3, force=10) +
  scale_x_log10() +
  labs(title="Continentes-riqueza en 2007 (no ponderado)")
```

<br>

#### LA FAMILIA APPLY 

<br>

Permiten vectorizar las operaciones de forma eficiente.

<br>

##### TAPPLY

<br>

Es una alternativa a `aggregate()` para aplicar una función de agregación sobre una única columna y segmentando por un único eje.

<br>

```{r}
tapply(paises07$esperanza_de_vida,paises07$continente,quantile,probs=0.25)
```

<br>

##### LAPPLY

<br>

Permite aplicar una función sobre cada elemento de un vector o lista. Devuelve una lista.

<br>

```{r}
lapply(paises07[,-1], function(x) class(x))
```

<br>

##### SAPPLY

<br>

Misma funcionalidad que lapply, pero simplificando el resultado a vector cuando es posible.

<br>

```{r}
sapply(paises07, function(x) class(x))
```

<br>

##### APPLY

<br>

Calcula agregados sobre cada una de los vectores marginas fila (`MARGIN = 1`), alternativamente columna (`MARGIN = 2`) de una matriz.

<br>

```{r}
a <- matrix(1:10,ncol=2)
apply(a,MARGIN = 1,sum)
```

<br>

Columnas,

<br>

```{r}
a <- matrix(1:10,ncol=2)
apply(a,2,sum)
```

<br>

#### LAS ALTERNATIVAS TYDIVERSE

<br>

El universo de [Tydiverse](https://www.tidyverse.org/) consiste en una colección de packages de R orientados al Data Science. Se recomienda la consulta del libro online [R para Ciencia de Datos](https://es.r4ds.hadley.nz/index.html).  

El package *dplyr*, al igual que *ggplot2*, está desarrollado por Hadley Wickham. Este paquete, supone un cambio de filosofía en la forma de trabajar con los datos y se está transformando en un nuevo estándar en R.

<br>

##### DPLYR: ARRANGE, FILTER, SELECT

<br>

- `arange`: Ordena los registros de un data frame.
- `filter`: Filtra a partir de un conjunto condiciones lógicas.
- `select`: Selecciona las columnas.

<br>

> \<ejemplo\>Paises asiaticos con PIB per cápita inferior a 1000 $ en 2007.\</ejemplo\>

<br>

```{r}
pais07dplyr <- paises07 %>% 
  arrange(desc(esperanza_de_vida)) %>% 
  filter(continente=='Asia' & pib_per_capita < 1000) %>% 
  select(pais,esperanza_de_vida,pib_per_capita)
```

<br>

```{r echo=FALSE, results='hide', warning=FALSE}
options(knitr.kable.NA = NA)
kable(pais07dplyr, "html", booktabs=TRUE,align="r", row.names = TRUE,) %>%
  kable_styling(bootstrap_options=c("striped", "hover", "condensed", "responsive")
                ,font_size = 11,full_width = F,) %>%
  column_spec(1:ncol(pais07dplyr),monospace=TRUE) %>%
  save_kable("www/pais07dplyr.png")
options(knitr.kable.NA = '')
```

![](www/pais07dplyr.png){width=200px}

\<imagen1\>(www/pais07dplyr.png){width=200px}

<br>

Las 3 comparten el hecho que no necesitan de comillas para referirse a las columnas. También utilizan el operador `%>%` llamado *pipe*. Éste sustituye el parámetro de entrada de datos. De esta forma, permite escribir las operaciones de izquierda a derecha facilitando así su lectura.

<br>

##### DPLYR: MUTATE, GROUP_BY, SUMMARISE

<br>

- `mutate`: Crea o modifica las columnas del data frame.
- `group_by`: Especifica una o varias columnas de agrupación.
- `summarise`: define los agregados de las columnas originales.

<br>

> \<ejemplo\>Esperanza de vida y PIB per cápita medio por continente y año.\</ejemplo\>

<br>

```{r, warning=FALSE, message=FALSE}
continentes_anio <- paises %>% 
  arrange(continente,anio) %>% 
  mutate(esperanza_de_vida_total = esperanza_de_vida * poblacion
         , pib_total = pib_per_capita * poblacion) %>% 
  group_by(continente,anio) %>% 
  summarize(n_paises=n()
            , esperanza_de_vida = sum(esperanza_de_vida_total ) /
                sum(poblacion )
            , pib_per_capita = sum(pib_total) / 
              sum(poblacion)
            , poblacion = sum(poblacion))
```

<br>

```{r echo=FALSE, results='hide', warning=FALSE}
options(knitr.kable.NA = NA)
kable(continentes_anio %>% head(10), "html", booktabs=TRUE,align="r", row.names = TRUE,) %>%
  kable_styling(bootstrap_options=c("striped", "hover", "condensed", "responsive")
                ,font_size = 11,full_width = F,) %>%
  column_spec(1:ncol(continentes_anio %>% head(10)),monospace=TRUE) %>%
  save_kable("www/continentes_anio.png")
options(knitr.kable.NA = '')
```

![](www/continentes_anio.png){width=350px}

\<imagen1\>(www/continentes_anio.png){width=350px}

<br>

Para la evolución de los continentes en ggplot2, es útil el [geom_path()](https://ggplot2.tidyverse.org/reference/geom_path.html.) 

<br>

```{r plot9, warning=FALSE, message=FALSE, fig.width=7, fig.cap='Fuente: Elaboración propia con datos de Gapminder. (plot9-1.png)'}
ggplot(continentes_anio, aes(x=pib_per_capita
                          , y=esperanza_de_vida
                          , color =continente)) +
  geom_path() +
  scale_x_log10() +
  geom_text_repel(aes(label=anio), size=2, color="black") +
  labs(title="Evolución continentes (ponderado)")
```

<br>

##### ACTIVIDAD GUIADA 1.5.

<br>

Incorporar los gráficos de evolución de los continentes en la actividad 1.5.

<br>

### 1.7.4 Lubridate: gestión de fechas y horarios

<br>

Para obtener el día actual con *lubridate* utiliza `today()`, día y hora con now().  

<br>

```{r, message=FALSE, warning=FALSE}
library(lubridate)
today()
now()
```

<br>

###### CREAR FECHAS  HORAS

<br>

Para crear fechas.

<br>

```{r}
ymd("2017-01-31") # Días des de texto
ymd_hms("2017-01-31 20:11:59")  # Día y hora des de texto
make_datetime(2020, 08, 24, 15, 36) # Des de los componentes
as_datetime(today()) # Conversión
```

<br>

###### OBTENER COMPONENTES

<br>

Para obtener los meses y días de la semana en Castellano. 

<br>

```{r, warning=FALSE, message=FALSE}
Sys.setlocale(locale="es_ES.UTF-8")

fechahora <- ymd_hms("2019-03-28 15:11:23")

year(fechahora)
month(fechahora, label = TRUE)  # meses en texto
wday(fechahora, label = TRUE, abbr = FALSE)    # días de la semana sin abreviar
```

<br>

###### MODIFICAR FECHAS Y HORAS

<br>

Editar componentes.

<br>

```{r}
year(fechahora) <- 2020
fechahora
hour(fechahora) <- hour(fechahora) + 10
fechahora
```

<br>

También resulta interesante los distintos tipos de redondeo de fechas.

<br>

```{r}
floor_date(fechahora, "month")
```

<br>

Alternativamente `round_date()` para aproximar y `ceiling_date()` valor por encima.

<br>

###### DURACIONES

<br>

Se miden en segundos. 

<br>

```{r}
edad_h <- today() - ymd(19760623)
edad_h
as.duration(edad_h)
```

<br>

¡Ten cuidado! Están condicionados a cambios de huso horario (hibierno/verano). 

<br>

```{r}
fechahora <- ymd_hms("2020-03-28 15:11:23", tz = "Europe/Madrid")
fechahora
fechahora + dhours(24)
```

<br>

###### PERIODOS

<br>

No se miden en segundos si no directamente en la unidad definida.

<br>

```{r}
fechahora + hours(24)
```

<br>

Ahora ya no hay la problemática del cambio de huso horario.


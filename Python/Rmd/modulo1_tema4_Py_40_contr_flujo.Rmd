
## CONTROL DE FLUJO

__[Abre en Colab](https://colab.research.google.com/github/griu/mbdds_fc20/blob/master/Python/modulo1_tema4_Py_40_contr_flujo.ipynb)__

Las herramientas de control de flujo permiten automatizar tareas. En este capítulo se trabajarán las funciones condicionales y bucles.

##### DATOS DE EJEMPLO

Este capítulo, utilizara ejemplos de vehículos de Star Wars.

```{python}
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns; sns.set()  # para el estilo de graficos

entidades = ['planets','starships','vehicles','people','species']
entidades_df = {x: pd.read_pickle('www/' + x + '_df.pkl') for x in entidades}
vehicles_df = entidades_df['vehicles'][["cost_in_credits","length","max_atmosphering_speed"
                                        ,"crew","cargo_capacity","pilots","films"]].dropna()

vehicles_df.head()
```

### FUNCIONES

Hagamos un breve repaso sobre lo que se ha tratado hasta el momento respecto a las funciones en Python. 

Se ha introducido el concepto de función en Python en el capítulo de [Elementos básicos de Python](modulo1_tema4_Py_10_elem_bas.ipynb). 

A continuación, en el capítulo de [Listas, tuplas y diccionarios](modulo1_tema4_Py_30_colec_obj.ipynb), se ha explicado la posibilidad de devolver varios elementos a la vez en forma de tuplas.

En [numpy](modulo1_tema4_Py_31_numpy.ipynb) se han explicado las funciones universales (ufunc), como una grupo de funciones que vectorizan al aplicarse sobre los elementos de los array numpy. 

Finalmente, en [pandas](modulo1_tema4_Py_32_pandas.ipynb), se ha comentado la posibilidad de aplicar las funciones universales de numpy a objetos pandas (Series y DataFrame) y como estas funciones respetan los índices fila y columna. También se ha comentado el alineamiento de los índices cuando se realizan operaciones aritméticas entre dos objetos pandas.

En el capítulo de gestión de datos, se tratará 2 conceptos adicionales sobre las funciones.

Por un lado, se verá como vectorizar cualquier tipo de función, sobre los elementos de los objetos pandas, a través de la función apply.

> **Recuerda**: En el tema de R las funciones apply ya se definieron con la misma finalidad.

El segundo concepto, van a ser las funciones de agregación (suma, media, cuantiles...). Éstas se definirán primero sobre objetos numpy y posteriormente sobre pandas.

La combinación de ambos conceptos, funciones vectorizadas y funciones de agregación sobre objetos pandas, van a terminar de rellenar tu caja de herramientas para poder iniciarte en data science.

### CONDICIONALES

Hagamos también aquí un breve repaso de los aspectos que ya se han comentado respecto a estructuras condicionales.

En el capítulo de los [Elementos básicos de Python](modulo1_tema4_Py_10_elem_bas.ipynb) se ha introducido la estructura básica *if-else*. 

En el capítulo [Listas, tuplas y diccionarios](modulo1_tema4_Py_30_colec_obj.ipynb) se ha utilizado la escritura if-else en las *list comprehension*.

```{python}
[x for x in range(5) if x%2==0]  # lista de pares menores a 5
```

Los capítulos de [Numpy](modulo1_tema4_Py_31_numpy.ipynb) y [Pandas](modulo1_tema4_Py_32_pandas.ipynb) también han servido para tratar los filtros, como un forma de operaciones condicionales sobre vectores y data frames.

Una nueva forma de realizar transformaciones condicionales con arrays numpy y series pandas es `np.where()`.

Por ejemplo, veamos la siguiente variable *crew* que nos informa del número de tripulantes que puede llevar como máximo un vehículo. 

```{python}
vehicles_df[['crew']].head()
```

Para transformar esta variable en una nueva que indique si un vehículo puede llevar 1, 2 o 3 o más tripulantes.

```{python}
vehicles_df['crew_r'] = np.where(vehicles_df.crew<3, vehicles_df.crew, 3)
vehicles_df[['crew','crew_r']].head()
```

> **Observa**: esta función de numpy aplica elemento a elemento. Observa también que se ha aplicado a una serie de un DataFrame, obteniendo una nueva serie.

### BUCLES

Los bucles for, se han tratado de forma básica en las *list comprehension* del capítulo de [Listas, tuplas y diccionarios](modulo1_tema4_Py_30_colec_obj.ipynb).

Una forma de definir bucles con for es a través de listas y diccionarios.

```{python}
crew_list = [1,2,3]
for n_crew in crew_list:
    
    n_vehi = vehicles_df[vehicles_df.crew_r == n_crew].shape[0]
    
    if n_vehi == 1:
        txt_vehicles = 'vehículo'
    else:
        txt_vehicles = 'vehiculos'
    
    txt_crew = 'tripulante'
    if n_crew != 1:
        txt_crew = txt_crew + 's'
    
    txt_n_crew = str(n_crew)
    if n_crew==3:
        txt_n_crew = txt_n_crew + ' o más'
    
    print("Hay {} {} con {} {}".format(n_vehi, txt_vehicles, txt_n_crew, txt_crew))
```

Este bucle recorre la lista `n_crew` y nos indica el número de vehículos con esa cantidad de tripulantes.

Cuando se recorre un diccionario con un `for`, por defecto, éste lo hace por sus claves.

```{python}
vehiculos_tripulantes = {'un': 8, 'dos': 3, '3 o más': 6}

for x in vehiculos_tripulantes:
    print(x)
```

Se puede iterar sobre la tupla `(clave,valor)` con `.items()`

```{python}
for txt_n_crew, n_vehi in vehiculos_tripulantes.items():
    print("Hay",n_vehi,"vehículo/s con",txt_n_crew, "tripulante/s")
```

Los bucles con numpy, tienen una lógica simétrica a las listas. 

Para poder recorrer 2 colecciones de objetos (listas, diccionarios, numpy, series...) con el mismo número de elementos de forma correlativa se utiliza la función `zip()`.

```{python}
a = [1,2,3]
b = [8,3,6]

for x,y in zip(a,b):
    print("Hay",y,"vehículo/s con",[x if x<3 else '3 o más'][0], "tripulante/s")
```

Para iterar **por columnas** de un DataFrame se utiliza `.iteritems()`. En cada iteración se obtiene la tupla`(nombre columna, valor serie)`. 

```{python}
for nombreCol,variable in vehicles_df.iteritems():
    print(nombreCol,", tiene tipo:",variable.dtype)
```

De la misma forma, pero ahora iterando un DataFrame **por filas** con `.iterrows()`.

```{python}
for nombre,fila in vehicles_df.iloc[0:2,0:2].iterrows():
    print(nombre,", cuesta:",fila.cost_in_credits," y mide:",fila.length , "metros")
```


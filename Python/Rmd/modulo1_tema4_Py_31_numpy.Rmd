
## 2.6. Numpy

__[Abre en Colab](https://colab.research.google.com/github/griu/mbdds_fc20/blob/master/Python/modulo1_tema4_Py_31_numpy.ipynb)__

El package [numpy](https://numpy.org/) es la solución más popular dentro de Python para realizar computación científica.

Recoge las mejores prácticas introducidas en las Listas y organizadas para realizar cálculos de forma eficiente. Se estructuran como vectores o arrays de N, dimensiones de un mismo tipo de dato.

El primer paso, consiste en cargar la librería, habitualmente con *namespace* `np`.

```{python}
import numpy as np
```

##### ACTIVIDAD GUIADA 2.3

Antes de entrar en materia vamos a presentar la actividad guiada de *numpy*.

Se trata de seleccionar la nave interestelar más rápida en MGLT (Megaluz / Hora), que pueda llevar a 4 tripulantes (como los protagonistas: Han Solo, Leia, Luke y Chewbacca). Además el coste de la nave debe ser com máximo 1M de créditos interestelares.

>     «Es la chatarra más veloz de la galaxia.» 
    ―Lando Calrissian
    
Lando se refería al Halcón Milenario. ¿Será verdad?

Para la actividad contamos con los siguiente datos em formato pandas.

```{python}
import pandas as pd
import matplotlib.pyplot as plt
import seaborn; seaborn.set()  # para el estilo de graficos

entidades = ['planets','starships','vehicles','people','species']
entidades_df = {x: pd.read_pickle('www/' + x + '_df.pkl') for x in entidades}
starships_df = entidades_df['starships'][["cost_in_credits","MGLT","crew"]].dropna()

starships_df.head()
```

Transformamos la matriz numpy con las columnas numéricas:

```{python}
starship_np = starships_df.values
starship_np # las filas son las naves y las columnas: cost_in_credits, MGLT y crew
```

Nombres de las naves a array numpy.

```{python}
starship_names = starships_df.index.values 
starship_names
```

#### TIPO DE DATOS EN NUMPY
Habitualmente se crean a partir de listas o tuplas con elementos homogéneos.

```{python}
b_np = np.array([True, False, False]) # booleano
b_np
```

```{python}
s_np = np.array(['f', 'h', 'j']) # string
s_np
```

```{python}
i_np = np.array(range(3)) # entero
i_np
```

```{python}
f_np = np.array([2.4, 1.5, 3.0]) # coma flotante
f_np
```

Los 4 objetos comparten ser de tipo `numpy.ndarray`.

```{python}
ej_np = (b_np, s_np, i_np, f_np)
[type(x) for x in ej_np]
```

Sin embargo, cada uno tiene un tipo interno accesible con el método `.dtype` .

```{python}
[x.dtype for x in ej_np]
```

Observa que numpy define sus propios nombres para los tipos básicos donde añade el tamaño en bits:

- 'U1' es texto Unicode de 1 bit.
- 'int64', 'float64' numéricos de 64 bits. 

Se puede definir este tipo en su construcción. 

```{python}
i_np = np.array(range(3), dtype='int16')
i_np
```

O convertir el numpy de un tipo interno a otro en un nuevo objeto con `.astype()` 

```{python}
s_i_np = i_np.astype(str)
s_i_np
```

El tipo de la matriz numérica de las naves es:

```{python}
starship_np.dtype
```

El vector de nombres tiene dtype object. Este tipo se utiliza para numpy de texto.

```{python}
starship_names.dtype
```

Así se ve mejor.

```{python}
print(starship_names.dtype)
```

#### FUNCIONES UNIVERSALES

En numpy las funciones universales o *ufunc*, son un conjunto de funciones vectorizan, es decir, que al aplicarlas sobre un objeto numpy, esta función, se aplica sobre cada uno de los elementos que lo componen. 

> **Recuerda**: Ya se comentó las funciones que vectorizan en el capitulo de funciones de R. 

Típicamente, las funciones de este tipo son las funciones aritméticas.

```{python}
np.array([1,2,3]) * 2  # multiplicación por escalar
```

```{python}
np.array([1,2,3]) + np.array([4,5,6]) # suma vectores
```

```{python}
np.array([1,2,3]) * np.array([4,5,6]) # producto elemento a elemento
```

NumPy ofrece una extensa colección de funciones matemáticas que se aplican de forma vectorial. Algunas de ellas son:  `abs`,`sign`, `sqrt`, `log`, `log10`, `exp`, `sin`, `cos`, `tan`, `arcsin`, `arccos`, `arctan`, `sinh`, `cosh`, `tanh`, `arcsinh`, `arccosh` y `arctanh`.

```{python}
np.sqrt(np.array([1,2,3,4]))
```

#### SECUENCIAS EN NUMPY

La función propia de numpy es `np.arange(ini,fin,paso)`

```{python}
np.arange(0,6,2)
```

Secuencias de ceros.

```{python}
np.zeros(3)
```

```{python}
np.ones(3)
```

Repetir todo el vector.

```{python}
a = [1,2,3]
b = np.tile(a, 4)
b
```

Repetir cada elemento de un vector.

```{python}
a = [1,2,3]
b = np.repeat(a, 4)
b
```

#### DIMENSIONES EN NUMPY

```{python}
np.random.seed(123)  # Semilla para poder reproducir

x1 = np.random.randint(10, size=6)  # array 1-dimensional 
x2 = np.random.randint(10, size=(3, 4))  # array 2-dimensional
x3 = np.random.randint(10, size=(3, 4, 5))  # array 3-dimensional 
```

```{python}
print("x3 número dimensiones: ", x3.ndim)
print("x3 shape:", x3.shape)
print("x3 número de elmentos: ", x3.size)
print("X3 cantidad de bytes:", x3.nbytes, "bytes")
```

Nuestra matriz de naves interestelares.

```{python}
print("Naves número dimensiones: ", starship_np.ndim)
print("Nombres número dimensiones: ", starship_names.ndim)
print("Naves shape:", starship_np.shape)
print("Nombres shape:", starship_names.shape)
print("Naves número de elmentos: ", starship_np.size)
print("Nombres número de elmentos: ", starship_names.size)
print("Naves cantidad de bytes:", starship_np.nbytes, "bytes")
print("Nombres cantidad de bytes:", starship_names.nbytes, "bytes")
```

### 2.6.1. Filtros en Numpy

Siguen las mismas reglas que en las listas, pero ahora con más dimensiones

```{python}
x2
```

Elemento de la matriz.

```{python}
x2[0, 0]
```

#### FILTROS SLICING

Vector segunda columna.

```{python}
x2[:,1]
```

Vector tercera fila.

```{python}
x2[2,:]
```

O, la misma fila, por omisión del segundo elemento.

```{python}
x2[2]
```

En nuestras naves, las columnas era: cost_in_credits, MGLT, crew.

Para acceder a la velocidad (MGLT).

```{python}
starship_np[:,1]
```

Para seleccionar la 5ª nave, se selecciona una fila 4.

```{python}
starship_np[4,:]
```

Para ver su nombre.

```{python}
starship_names[4]
```

#### INDEXACIÓN ELEGANTE
##### FILTROS POSICIONALES

Otra mejora respecto a las listas es la capacidad de indexar por una lista o array.

Para filtrar por un array unidimensional de posiciones.

```{python}
x1
```

```{python}
ind = [0,2,5]
x1[ind]
```

> **Recuerda**: En el objeto list, esta operación no es posible. En su lugar se utilizan las list comprehension.

En 2 dimensiones, a diferencia de lo visto en R, se aparean por coordenadas filas y columnas, es lo que se llama Broadcasting. Lo verás más adelante.

```{python}
x2
```

```{python}
fils = np.array([0,1])
cols = np.array([0,3])

x2[fils,cols]
```

> **Recuerda**: en arrays numpy los filtros por posición, se seleccionan apareando coordenadas fila y columna. Ve a la sección de Broadcasting, para saber más!

En R se obtendría el siguiente resultado.

```{python}
x2[fils,:][:,cols]
```

##### FILTROS LÓGICOS 

Otro mecanismo *fancy indexing* son los filtros lógicos. 

Antes recordemos que para obtener el número de tripulantes (crew). 

```{python}
starship_np[:,2]
```

Para saber cuáles son las naves de 4 o más tripulantes. 

```{python}
starship_np[:,2] >= 4
```

Si queremos rescatar sus nombres.

```{python}
starship_names[starship_np[:,2] >= 4]
```

Continúan funcionando los operadores distinto `!=`, en `in`, no en `not in`.

```{python}
'Millennium Falcon' in starship_names[starship_np[:,2] >= 4]
```

> Para reproducir el mismo comportamiento que el operador `a %in% b` de R se utiliza `np.isin(a, b)` .

```{python}
a = np.array([1, 2, 3, 4])
b = np.array([3, 4, 5])
np.isin(a,b)
```

##### OPERACIONES BOOLEANAS

Se utilizan los `&`, `|` y `~` en vez de los `and`, `or`, `not` (respec.) utilizados en los tipos lógicos. Es necesario cerrar las expresiones entre paréntesis. 

Por ejemplo:

```
( A > 1 ) |  ( B < 5)
```

Respecto a nuestras naves, las que tienen 4 o más tripulantes y de cuestan menos de 1M de créditos.

```{python}
starship_names_sel = starship_names[(starship_np[:,2] >= 4) & (starship_np[:,0] <10**6)]
starship_names_sel
```

> **Recuerda**: las 2 expresiones van entre paréntesis.

Ahora filtramos la matriz de datos de estas naves.

```{python}
starship_np_sel = starship_np[(starship_np[:,2] >= 4) & (starship_np[:,0] <10**6), :]
starship_np_sel
```

Gráficamente.

```{python}
starship_names_sel
```

```{python}
ind = np.arange(len(starship_names_sel))    # posiciones

plt.bar(ind, starship_np_sel[:,1] );

for i in ind:
    plt.text(ind[i],starship_np_sel[i,1], int(starship_np_sel[i,1]),size=9)

plt.gcf().subplots_adjust(left=0.15,bottom=0.15)
plt.ylabel('Velocidad (MGLT)')
plt.title('Naves Interestelares seleccionadas')
p = plt.xticks(ind, starship_names_sel,fontsize=9);
plt.show();
```

Parece que el Halcón Milenario con 75 MGLT, es la nave que andábamos buscando!

### 2.6.2. Modificar arrays

Para modificar un valor de un array.

```{python}
x2
```

```{python}
x2[1,1] = 20
x2
```

Mucha precaución con el tipo interno del numpy ya que es fijo. No se va a modificar.

```{python}
x2[1,1] = 20.765
x2
```

> **Recuerda**: Si intentas insertar un valor en coma flotante sobre un numpy con tipo entero, éste se va a cortar.

Se puede modificar N valores con un vector de N posiciones.

```{python}
x2[1,:] = x2[0,:] * 10 
x2
```

También, se pueden modificar varios a la vez, con un único valor.

```{python}
x2[[1,2],[2,2]] = 55
x2
```

#### VISTAS NO COPIADAS

Cuando se asigna un array numpy a otro objeto, ya sea filtrado con `[,]` o no, éste retorna una vista, no una copia. Es muy importante tenerlo en cuenta, cuando se modifica el objeto.

```{python}
x2
```

```{python}
x2_1 = x2
```

```{python}
x2_1[1,0] = 11 
```

```{python}
x2_1
```

> **Importante**: Los cambios en una vista no copiada, afectan a todas las copias!!!

#### COPIAS DE ARRAYS

Para copiar un array a otro objeto utiliza `copy()`.

```{python}
x2_2 = x2.copy()
```

```{python}
x2_2[0,0] = 50 
```

```{python}
x2
```

Ahora, el objeto original, no cambia.

#### CAMBIOS DE *SHAPE*

Con `.reshape()` se puede modificar las dimensiones del array.

```{python}
x1
```

```{python}
x1.reshape(2,3)
```

#### CONCATENAR ARRAYS

Para concatenar 2 arrays unidimensionales.

```{python}
x = np.array([1, 2, 3])
y = np.array([3, 2, 1])
np.concatenate([x, y])
```

```{python}
grid = np.arange(6).reshape(2,3)

# concatenar filas, (axis = 0)
np.concatenate([grid, grid])
```

```{python}
# concatenar columnas, (axis = 1)
np.concatenate([grid, grid], axis=1)
```

Lo mismo con vstack y hstack, pero con arrays de distinta dimensión.

```{python}
x = np.array([1, 2, 3])
grid = np.array([[9, 8, 7],
                 [6, 5, 4]])

# apilado vertical
np.vstack([x, grid])
```

```{python}
# apilado horizontal
y = np.array([[99],
              [99]])
np.hstack([grid, y])
```

#### BROADCASTING DE ARRAYS

El Broadcasting es una operación de alineamiento que sigue de forma estricta las siguientes reglas de interacción entre 2 arrays:

- Regla 1: Si dos arrays difieren en el número de dimensiones, el shape (dimensiones) del que tenga menor dimensión se aumenta con unos por la izquierda.
```
[3,1,6] x [2,6] ----> [3,1,6] x [1,2,6]
[3,5,4] x [3,5] ----> [3,5,4] x [1,3,5]
```
- Regla 2: Si dos arrays tienen shape distinto en alguna dimensión, el array con shape igual a 1 se estira (copia) para que concuerde con el de la misma dimensión del otro array.

```
[3,1,6] x [1,2,6] ----> [3,2,6] x [3,2,6]
[3,5,4] x [1,3,5] ----> [3,5,4] x [3,3,5]
```
- Regla 3: Si alguna dimensión tiene tamaño distinto y no hay ninguna dimensión 1, se lanza un error.
```
[3,2,6] x [3,2,6] ----> Concuerdan
[3,5,4] x [3,3,5] ----> Error !!!
```

En la práctica, esto significa facilitar algunas operaciones.

```{python}
a = np.ones((2,2))
a
```

```{python}
b =  np.tile(0.5, 2)
b
```

```{python}
a - b
```

#### CONVERSIÓN A LISTAS

Los numpy se convierten a lista con `.tolist()`.

```{python}
a = np.array([2,3,7,3])
b = a.tolist()
b
```

```{python}
type(b)
```

#### VALORES FALTANTES

Por definición, un NaN es un número en coma flotante, distinto a cualquier otro número.

```{python}
np.nan != np.nan
```

```{python}
a = np.arange(6).reshape(3,2) * 1.0

a[[1,2],[1] ] = np.nan

a
```

> **Observa**: como se ha aplicado broadcast al asignar `np.nan`. 

```{python}
np.isnan(a)
```

Numpy es la base de la computación con arrays. Veamos ahora qué aportan los objetos **pandas**.
